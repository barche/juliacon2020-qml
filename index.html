<!doctype html>
<html>

<head>
  <meta charset="utf-8">
  <meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=no">

  <title>reveal.js</title>

  <link rel="stylesheet" href="dist/reset.css">
  <link rel="stylesheet" href="dist/reveal.css">
  <link rel="stylesheet" href="dist/theme/black.css" id="theme">

  <!-- Theme used for syntax highlighted code -->
  <link rel="stylesheet" href="plugin/highlight/monokai.css" id="highlight-theme">
</head>

<body>
  <div class="reveal">
    <style>
      .reveal section pre code {
        font-size: 0.65em !important;
        line-height: normal !important;
      }
    </style>
    <div class="slides">
      <section>
        <h1>QML.jl</h1>
        <p>Easy and fast desktop GUIs with QML</p>
        <p><small>Slides and examples at <a href="https://github.com/barche/juliacon2020-qml">https://github.com/barche/juliacon2020-qml</a></small></p>
      </section>
      <section>
        <style>
          .container {
            display: flex;
          }

          .col {
            flex: 1;
          }
        </style>
        <section>
          <h2>Quick example</h2>
          <div class="container">

            <div class="col">
              <p data-id="code-title">Julia</p>
              <pre><code class="julia" data-trim>
                          using QML
                          using Observables
                          
                          slidervalue = Observable(0.0)
                          
                          load(
                            "slider.qml",
                            variables = JuliaPropertyMap(
                              "slidervalue" => slidervalue
                            )
                          )
                          
                          exec_async()
                        </code></pre>
            </div>

            <div class="col">
              <p data-id="code-title">QML</p>
              <pre><code class="qml" data-trim>
                          import QtQuick 2.6
                          import QtQuick.Controls 2.3
                          import QtQuick.Layouts 1.0
                          
                          ApplicationWindow {
                            visible: true
                            onClosing: Qt.quit()
                          
                            ColumnLayout {
                              Slider {
                                value: variables.slidervalue
                                onValueChanged: {
                                  variables.slidervalue = value
                                }
                              }
                          
                              Text {
                                text: variables.slidervalue
                              }
                            }
                          }                
                        </code></pre>
            </div>

          </div>
        </section>
        <section>
          <video data-autoplay src="https://github.com/barche/juliacon2020-qml/releases/download/v1.0/slider.mp4"></video>
        </section>
        <section>
          <div class="container">

            <div class="col">
              <p data-id="code-title">Julia</p>
              <pre><code class="julia" data-trim data-line-numbers="4|8|9">
                        using QML
                        using Observables
                        
                        slidervalue = Observable(0.0)
                        
                        load(
                          "slider.qml",
                          variables = JuliaPropertyMap(
                            "slidervalue" => slidervalue
                          )
                        )
                        
                        exec_async()
                      </code></pre>
            </div>

            <div class="col fragment">
              <p data-id="code-title">QML</p>
              <pre><code class="qml" data-trim data-line-numbers="11|13|18">
                        import QtQuick 2.6
                        import QtQuick.Controls 2.3
                        import QtQuick.Layouts 1.0
                        
                        ApplicationWindow {
                          visible: true
                          onClosing: Qt.quit()
                        
                          ColumnLayout {
                            Slider {
                              value: variables.slidervalue
                              onValueChanged: {
                                variables.slidervalue = value
                              }
                            }
                        
                            Text {
                              text: variables.slidervalue
                            }
                          }
                        }                
                      </code></pre>
            </div>
          </div>
        </section>
      </section>
      <section>
        <section>
          <h2>Displays</h2>
          <video height=500em data-autoplay src="https://github.com/barche/juliacon2020-qml/releases/download/v1.0/image.mp4"></video>
        </section>
        <section>
          <h3>QML code</h3>
          <pre><code class="qml" data-trim data-line-numbers="4|22-26|19">
            import QtQuick 2.6
            import QtQuick.Controls 2.3
            import QtQuick.Layouts 1.0
            import org.julialang 1.0

            ApplicationWindow {
              title: "My Application"
              width: 520
              height: 570
              visible: true

              ColumnLayout {
                spacing: 6
                anchors.centerIn: parent

                Button {
                  Layout.alignment: Qt.AlignCenter
                  text: "Push Me"
                  onClicked: Julia.showimage(juliaDisplay)
                }

                JuliaDisplay {
                  id: juliaDisplay
                  width: 512
                  height: 512
                }
              }
            }
          </code></pre>
        </section>
        <section data-auto-animate>
          <h3>Julia code</h3>
          <p><small>Defining functions for use in QML</small></p>
          <pre data-id="image-animation"><code class="julia" data-trim data-line-numbers="6-8">
            using Test
            using QML
            using Images
            using TestImages

            qmlfunction("showimage",
              d::JuliaDisplay -> display(d, testimage("mandrill"))
            )

            load("image.qml")

            # Run the application
            exec()
          </code></pre>
        </section>
        <section data-auto-animate>
          <h3>Julia code</h3>
          <p><small>Defining functions for use in QML</small></p>
          <pre data-id="image-animation"><code class="julia" data-trim data-line-numbers="6-7">
            using Test
            using QML
            using Images
            using TestImages

            showimage(d::JuliaDisplay) = display(d, testimage("mandrill"))
            @qmlfunction showimage

            load("image.qml")

            # Run the application
            exec()
          </code></pre>
        </section>
      </section>
      <section>
        <section>
        <h2>Listmodels</h2>
        <pre data-id="image-animation"><code class="julia" data-trim data-line-numbers="3-13|24-28|30-32">
          using QML

          # Julia Fruit model item. Each field is automatically a role, by default
          mutable struct Fruit
            name::String
            cost::Float64
            attributes::ListModel
          end

          # Attributes must have a description and are nested model items
          mutable struct Attribute
            description::String
          end

          # Construct using attributes from an array of QVariantMap, as in the append call in QML
          function Fruit(name, cost, attributes::AbstractArray)
            return Fruit(name, cost, ListModel([Attribute(QML.value(a)["description"]) for a in attributes]))
          end

          # Use a view, since no ApplicationWindow is provided in the QML
          qview = init_qquickview()

          # Our initial data
          fruitlist = [
            Fruit("Apple", 2.45, ListModel([Attribute("Core"), Attribute("Deciduous")])),
            Fruit("Banana", 1.95, ListModel([Attribute("Tropical"), Attribute("Seedless")])),
            Fruit("Cumquat", 3.25, ListModel([Attribute("Citrus")])),
            Fruit("Durian", 9.95, ListModel([Attribute("Tropical"), Attribute("Smelly")]))]

          # Set a context property with our listmodel
          fruitmodel = ListModel(fruitlist)
          set_context_property(qmlcontext(), "fruitModel", fruitmodel)

          # Load QML after setting context properties, to avoid errors on initialization
          qml_file = joinpath(dirname(@__FILE__), "qml", "dynamiclist.qml")
          set_source(qview, QUrl(qml_file))
          QML.show(qview)

          # Run the application
          exec()

          # Show that the Julia fruitlist was modified
          println("Your fruits:")
          for f in fruitlist
            println("  $(f.name), \$$(f.cost)")
          end
        </code></pre>
        </section>
        <section>
          <p><small>QML code is directly from the <a href="https://doc.qt.io/qt-5.12/qtquick-views-example.html#dynamic-list">dynamic list Qt example</a>, only the data model was moved from QML to Julia, as shown by the diff:</small></p>
          <img src="https://github.com/barche/juliacon2020-qml/releases/download/v1.0/qmldiff.png">
        </section>
        <section>
          <p><small>The model is supplied to an appropriate QML item:</small></p>
          <pre><code class="qml" data-trim data-line-numbers="|8">
            ListView {
              id: listView
              anchors {
                left: parent.left; top: parent.top;
                right: parent.right; bottom: buttons.top;
                margins: 20
              }
              model: fruitModel
              delegate: listDelegate
            }
          </code></pre>
        </section>
        <section>
          <p><small>Roles are available as variables inside the list delegates:</small></p>
          <pre><code class="qml" data-trim data-line-numbers="4">
            Text {
              id: costText
              anchors.verticalCenter: parent.verticalCenter
              text: '$' + Number(cost).toFixed(2)
              font.pixelSize: 15
              color: "white"
              font.bold: true
            }
          </code></pre>
        </section>
        <section>
          <video data-autoplay height=400em src="https://github.com/barche/juliacon2020-qml/releases/download/v1.0/dynamiclist.mp4"></video>
        </section>
        <section>
          <pre><code class="julia" data-trim>
            # Show that the Julia fruitlist was modified
            println("Your fruits:")
            for f in fruitlist
              println("  $(f.name), \$$(f.cost)")
            end
          </code></pre>
          <pre class="fragment"><code class="text" data-trim>
            Your fruits:
              Apple, $2.45
              Banana, $1.95
              Pizza Margarita, $7.7
              Cumquat, $3.25
              Durian, $9.95
          </code></pre>
        </section>
      </section>
      <section>
        <section>
          <h2>Faster displays</h2>
          <video controls height=500em src="https://github.com/barche/juliacon2020-qml/releases/download/v1.0/plots.mp4"></video>
        </section>
        <section>
          <h3>JuliaPaintedItem type</h3>
          <pre><code class="qml" data-trim data-line-numbers="55-60">
            import QtQuick 2.0
            import QtQuick.Controls 1.0
            import QtQuick.Layouts 1.0
            import org.julialang 1.1
            import QtQuick.Window 2.2

            ApplicationWindow {
              title: "My Application"
              width: 800
              height: 600
              visible: true

              ColumnLayout {
                id: root
                spacing: 6
                anchors.fill: parent

                RowLayout {
                  Layout.fillWidth: true
                  Layout.alignment: Qt.AlignCenter

                  Text {
                    text: "Amplitude:"
                  }

                  Slider {
                    id: amplitudeSlider
                    width: 100
                    value: 1.0
                    minimumValue: 0.1
                    maximumValue: 5.0
                    onValueChanged: { 
                      parameters.amplitude = value;
                      painter.update()
                    }
                  }

                  Text {
                    text: "Frequency:"
                  }

                  Slider {
                    id: frequencySlider
                    width: 100
                    value: 10.0
                    minimumValue: 1.0
                    maximumValue: 50.
                    onValueChanged: { 
                      parameters.frequency = value;
                      painter.update()
                    }
                  }
                }

                JuliaPaintedItem {
                  id: painter
                  paintFunction : paint_cfunction
                  Layout.fillWidth: true
                  Layout.fillHeight: true
                }
              }
            }
          </code></pre>
        </section>
        <section>
          <p>Use from Julia:</p>
          <pre><code class="julia" data-trim data-line-numbers="1|16-32|18-20|22-24|26-29">
            ENV["QSG_RENDER_LOOP"] = "basic" # multithreading in Qt must be off
            using CxxWrap # for safe_cfunction
            using QML
            using Observables

            # Set up plots with GR so QPainter can be used directly
            using Plots
            ENV["GKSwstype"] = "use_default"
            gr(show=true)

            const qmlfile = joinpath(dirname(Base.source_path()), "qml", "gr.qml")

            f = Observable(1.0)
            A = Observable(1.0)

            # Arguments here need to be pointers
            function paint(p::CxxPtr{QPainter}, item::CxxPtr{JuliaPaintedItem})  
              ENV["GKS_WSTYPE"] = 381
              ENV["GKS_CONID"] = split(repr(p.cpp_object), "@")[2]
              ENV["GKS_QT_VERSION"] = 5

              dev = device(p[])[]
              r = effectiveDevicePixelRatio(window(item[])[])
              w, h = width(dev) / r, height(dev) / r

              x = 0:π/100:π
              y = A[]*sin.(f[]*x)

              plot(x, y, ylims=(-5,5), size=(w, h))

              return
            end

            load(qmlfile,
              paint_cfunction = @safe_cfunction(paint, Cvoid, (CxxPtr{QPainter}, CxxPtr{JuliaPaintedItem})),
              parameters = JuliaPropertyMap("frequency" => f, "amplitude" => A))
            exec()

            """
            Example of GR.jl integration
            """

          </code></pre>
        </section>
        <section>
          <p>JuliaCanvas element provides fast image drawing</p>
          <video controls src="https://github.com/barche/juliacon2020-qml/releases/download/v1.0/circles.m4v"></video>
          <p><small>JuliaCanvas was <a href="https://github.com/barche/QML.jl/pull/67">contributed by @treygreer</a></small></p>
        </section>
        
      </section>
      <section>
        <section>
          <h2>Makie</h2>
          <p><small>MakieViewport QML element renders Makie scenes using GLMakie:</small></p>
          <video data-autoplay height=400em src="https://github.com/barche/juliacon2020-qml/releases/download/v1.0/makiecat.m4v"></video>
        </section>
        <section>
          <p><small>QML Repeater with ListModel overlay on top of Makie:</small></p>
          <video data-autoplay height=400em src="https://github.com/barche/juliacon2020-qml/releases/download/v1.0/makieplot.m4v"></video>
        </section>
        <section>
          <p>Model definition:</p>
          <pre><code class="julia" data-trim data-line-numbers="9-10|12|19|54-57|60-67|70">
            # MUST disable threading in Qt
            ENV["QSG_RENDER_LOOP"] = "basic"

            using CxxWrap
            using Observables
            using QML
            using Makie

            const xpos = Node(collect(0.1:0.05:0.3))
            const ypos = Node(rand(length(xpos[])))

            plotscene = lines(xpos, ypos, color = :blue)
            const needupdate = Observable(true)

            on(plotscene.data_limits) do l
              needupdate[] = true
            end

            positionmodel = ListModel(tuple.(xpos[], ypos[]), false)

            # Convert model coordinates to screen (inverse of to_world)
            function to_screen(scene, point)
              cam = scene.camera
              cam_res = widths(pixelarea(scene)[])
              prj_view = cam.projection[] * cam.view[] * Makie.AbstractPlotting.transformationmatrix(scene)[]
              pix_space = prj_view * Vec4f0(point[1], point[2], 0.0, 1.0)
              clip_space = (pix_space[1], pix_space[2])
              return ((clip_space .+ 1) ./ 2) .* cam_res
            end

            function update_scene(lm)
              l = length(lm)
              newx = zeros(l)
              newy = zeros(l)
              for i in 1:l
                (newx[i], newy[i]) = lm[i]
              end
              xpos[] = newx
              ypos[] = newy
              return
            end

            getscreenpos(xy::Tuple, i::Integer) = to_screen(plotscene, xy)[i]

            function setpos(lm, x_or_y, listidx, i)
              newpos = [lm[listidx]...]
              newpos[i] = x_or_y
              lm[listidx] = (newpos...,)
              update_scene(lm)
            end

            setscreenpos(lm, x_or_y, listidx, i) = setpos(lm, to_world(plotscene, Point2f0(x_or_y, x_or_y))[i], listidx, i)

            addrole(positionmodel, "xpos", xy -> xy[1], (lm, x_or_y, i) -> setpos(lm, x_or_y, i, 1))
            addrole(positionmodel, "ypos", xy -> xy[2], (lm, x_or_y, i) -> setpos(lm, x_or_y, i, 2))
            addrole(positionmodel, "xposscreen", xy -> getscreenpos(xy,1), (lm, x_or_y, i) -> setscreenpos(lm, x_or_y, i, 1))
            addrole(positionmodel, "yposscreen", xy -> getscreenpos(xy,2), (lm, x_or_y, i) -> setscreenpos(lm, x_or_y, i, 2))

            # Render function that takes a parameter t from a QML slider
            function render_function(screen)
              display(screen, plotscene)
              if needupdate[] # The screen positions change if a resize happens and are unknown before the first render
                QML.force_model_update(positionmodel)
                needupdate[] = false
              end
              return
            end

            load(joinpath("makie.qml"),
              positionModel = positionmodel,
              updates = JuliaPropertyMap("needupdate" => needupdate),
              render_callback = @safe_cfunction(render_function, Cvoid, (Any,))
            )
            exec()

          </code></pre>
        </section>
        <section>
          <p>Model usage:</p>
          <pre><code class="qml" data-trim data-line-numbers="3|13|18-19">
            Repeater {
              anchors.fill: parent
              model: positionModel

              Item {
                id: pointDelegate
                // ...

                      TextField {
                        id: xField
                        Layout.preferredWidth: 60
                        Layout.preferredHeight: 25
                        onAccepted: { xpos = parseFloat(text); updates.needupdate = true; viewport.update(); }
                      }

                // Set initial point positions
                Component.onCompleted: {
                  x = xposscreen/Screen.devicePixelRatio - pointMarker.width/2;
                  y = appRoot.height - yposscreen/Screen.devicePixelRatio - pointMarker.height/2;
                }
              }
            }
          </code></pre>
        </section>
      </section>
      <section>
        <h2>Styling</h2>
        <small>
        <table>
          <thead>
            <tr>
              <th>Style</th>
              <th>Mac</th>
              <th>Linux</th>
            </tr>
          </thead>
          <tbody>
            <tr>
              <td>QQuick 1</td>
              <td><img src="https://github.com/barche/juliacon2020-qml/releases/download/v1.0/style-mac-qqc1.png" height=100em></td>
              <td><img src="https://github.com/barche/juliacon2020-qml/releases/download/v1.0/style-linux-qqc1.png" height=100em></td>
            </tr>
            <tr>
              <td>Default</td>
              <td><img src="https://github.com/barche/juliacon2020-qml/releases/download/v1.0/style-mac-default.png" height=100em></td>
              <td><img src="https://github.com/barche/juliacon2020-qml/releases/download/v1.0/style-linux-default.png" height=100em></td>
            </tr>
            <tr>
              <td>QQC2</td>
              <td><img src="https://github.com/barche/juliacon2020-qml/releases/download/v1.0/style-mac-qqc2.png" height=100em></td>
              <td><img src="https://github.com/barche/juliacon2020-qml/releases/download/v1.0/style-linux-qqc2.png" height=100em></td>
            </tr>
          </tbody>
        </table>
        </small>
      </section>
      <section>
        <h2>Future work</h2>
        <ul>
          <li>Some easy templates for Makie integration</li>
          <li>Cleaner GR integration</li>
          <li>Native look for QtQuickControls 2 using <a href="https://api.kde.org/frameworks/qqc2-desktop-style/html/index.html">QQC2 from KDE</a></li>
          <li>Use of Observables in ListModel</li>
        </ul>
      </section>
      <!-- <section>
        <section data-auto-animate>
          <h2>Building a GUI</h2>
          <p>Times tables:</p>
          <pre data-id="times-output-animation"><code class="text" data-trim>
            1 × 2 = ?
          </code></pre>
        </section>
        <section data-auto-animate>
          <p>Times tables:</p>
          <pre data-id="times-output-animation"><code class="text" data-trim>
            1 × 2 = ?
            2
          </code></pre>
        </section>
        <section data-auto-animate>
          <p>Times tables:</p>
          <pre data-id="times-output-animation"><code class="text" data-trim>
            1 × 2 = ?
            2
            Correct!
            2 × 4 = ?
          </code></pre>
        </section>
        <section data-auto-animate>
          <p>Times tables:</p>
          <pre data-id="times-output-animation"><code class="text" data-trim>
            1 × 2 = ?
            2
            Correct!
            2 × 4 = ?
            3
            Incorrect!
            2 × 4 = ?
            8
            Correct!
          </code></pre>
          <p>Text interface and GUI based on the same code.</p>
        </section>
        
        <section>
        <h3>Common Julia code</h3>
          <pre><code class="julia" data-trim data-line-numbers="1|3-4|5-6|7-8|10-14|16-19|21-24|26-29|31-39|41-44">
          using Observables

          # The factors to multiply
          const factors = Observable((1,2))
          # The entered and parsed result
          const result = Observable(0)
          # True if the result is correct
          const success = Observable(false)

          # Translate the problem to a nice string
          function makeprompt(f)
            a,b = f
            return "$a × $b = ?"
          end

          # String representation of the problem
          const prompt = Observable(makeprompt(factors[]))
          const statusstring = Observable("")
          const resultstring = Observable("")

          # Update the prompt when the factors change
          on(factors) do f
            prompt[] = makeprompt(f)
          end

          # Evaluate correctness of result
          on(result) do r
            success[] =  (r == prod(factors[]))
          end

          # Give a new problem if correct
          on(success) do s
            if s
              factors[] = (rand((2,5,10)), rand(1:10))
              statusstring[] = "Correct!"
            else
              statusstring[] = "Incorrect!"
            end
          end

          # Parse string input
          on(resultstring) do s
            result[] = parse(Int, s)
          end
          </code></pre>
          <p><small>times.jl</small></p>
        </section>

        <section>
          <h3>Text Interface</h3>
          <pre><code class="julia" data-trim data-line-numbers="1|3-5|7-10">
          include("times.jl")
          
          on(statusstring) do s
            println(s)
          end
          
          for i in 1:3
            println(prompt[])
            resultstring[] = readline()
          end
          </code></pre>
        </section>

        <section>
          <h3>QML Interface</h3>
          <pre><code class="julia" data-trim data-line-numbers="1|3|5-11|13">
          include("times.jl")

          using QML

          load("times.qml",
            problem=JuliaPropertyMap(
              "prompt" => prompt,
              "resultstring" => resultstring,
              "statusstring" => statusstring,
            )
          )

          exec()
          </code></pre>
        </section>
        <section>
          <video data-autoplay src="https://github.com/barche/juliacon2020-qml/releases/download/v1.0/times.mp4"></video>
        </section>
        <section>
          <h3>A look at the QML</h3>
          <pre><code class="qml" data-trim data-line-numbers>
            import QtQuick 2.6
            // ...
            import org.julialang 1.0

            ApplicationWindow {
              // ...

              ColumnLayout {
                spacing: 6
                // ...

                RowLayout {
                  // ...

                  Text {
                    text: problem.prompt
                  }

                  TextField {
                    id: answer
                    onAccepted: problem.resultstring = text
                  }

                  Button {
                    onClicked: problem.resultstring = text
                  }
                }

                Rectangle {
                  id: feedback
                  state: problem.statusstring

                  ColumnLayout {
                    // ...
                    Text {
                      id: statusText
                      text: qsTr("Please solve the problem")
                    }
                  }

                  states: [
                    State {
                      name: "Correct!"
                      // Set color...
                    },
                    State {
                      name: "Incorrect!"
 
                    }
                  ]
                }
              }

            }

          </code></pre>
        </section>
      </section> -->
    </div>
  </div>

  <script src="dist/reveal.js"></script>
  <script src="plugin/notes/notes.js"></script>
  <script src="plugin/markdown/markdown.js"></script>
  <script src="plugin/highlight/highlight.js"></script>
  <script>
    // More info about initialization & config:
    // - https://revealjs.com/initialization/
    // - https://revealjs.com/config/
    Reveal.initialize({
      hash: true,

      // Learn about plugins: https://revealjs.com/plugins/
      plugins: [RevealMarkdown, RevealHighlight, RevealNotes]
    });
  </script>
</body>

</html>